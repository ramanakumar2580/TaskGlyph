{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/ramanakumar/taskglyph/src/lib/db/clientDb.ts"],"sourcesContent":["import Dexie from \"dexie\";\n\n// Create a subclass of Dexie for type safety\nclass TaskGlyphDB extends Dexie {\n  tasks!: Dexie.Table<Task, string>;\n  notes!: Dexie.Table<Note, string>;\n  diaryEntries!: Dexie.Table<DiaryEntry, string>;\n  pomodoroSessions!: Dexie.Table<PomodoroSession, string>;\n  syncOutbox!: Dexie.Table<SyncOperation, string>;\n  userMetadata!: Dexie.Table<UserMetadata, string>;\n\n  constructor() {\n    super(\"TaskGlyphDB\");\n\n    // ✅ 1. Bump the database version\n    this.version(2).stores({\n      userMetadata: \"userId\",\n      tasks: \"id, title, completed, createdAt, updatedAt\",\n      notes: \"id, title, createdAt, updatedAt\",\n      diaryEntries: \"id, entryDate, createdAt\",\n      // ✅ 2. Add 'type' to the pomodoroSessions table\n      pomodoroSessions: \"id, durationMinutes, completedAt, type\",\n      syncOutbox: \"id, entityType, operation, timestamp\",\n    });\n\n    // This was your old version 1, we keep it for migrations\n    this.version(1).stores({\n      userMetadata: \"userId\",\n      tasks: \"id, title, completed, createdAt, updatedAt\",\n      notes: \"id, title, createdAt, updatedAt\",\n      diaryEntries: \"id, entryDate, createdAt\",\n      pomodoroSessions: \"id, durationMinutes, completedAt\",\n      syncOutbox: \"id, entityType, operation, timestamp\",\n    });\n  }\n}\nexport interface UserMetadata {\n  userId: string;\n  trialStartedAt: number; // timestamp\n  tier: \"free\" | \"basic\" | \"pro\" | \"ultra_pro\";\n}\n// Define TypeScript interfaces for your data\nexport interface Task {\n  id: string;\n  title: string;\n  completed: boolean;\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface Note {\n  id: string;\n  title: string;\n  content: string;\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface DiaryEntry {\n  id: string;\n  entryDate: string; // YYYY-MM-DD\n  content: string;\n  createdAt: number;\n}\n\n// ✅ 3. Add the 'type' field to the interface\nexport interface PomodoroSession {\n  id: string;\n  durationMinutes: number;\n  completedAt: number;\n  type: \"work\" | \"break\"; // New field\n}\n\nexport type EntityType = \"task\" | \"note\" | \"diary\" | \"pomodoro\";\nexport type OperationType = \"create\" | \"update\" | \"delete\";\n\nexport interface SyncOperation {\n  id: string;\n  entityType: EntityType;\n  operation: OperationType;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  payload: any;\n  timestamp: number; // client-side timestamp in milliseconds\n}\n\n// Export a singleton instance\nconst db = new TaskGlyphDB();\n\nexport default db;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,6CAA6C;AAC7C,MAAM,oBAAoB,sJAAK;IAC7B,MAAkC;IAClC,MAAkC;IAClC,aAA+C;IAC/C,iBAAwD;IACxD,WAAgD;IAChD,aAAiD;IAEjD,aAAc;QACZ,KAAK,CAAC;QAEN,iCAAiC;QACjC,IAAI,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC;YACrB,cAAc;YACd,OAAO;YACP,OAAO;YACP,cAAc;YACd,gDAAgD;YAChD,kBAAkB;YAClB,YAAY;QACd;QAEA,yDAAyD;QACzD,IAAI,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC;YACrB,cAAc;YACd,OAAO;YACP,OAAO;YACP,cAAc;YACd,kBAAkB;YAClB,YAAY;QACd;IACF;AACF;AAkDA,8BAA8B;AAC9B,MAAM,KAAK,IAAI;uCAEA","debugId":null}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"sources":["file:///Users/ramanakumar/taskglyph/src/lib/sync/syncService.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport db from \"@/lib/db/clientDb\";\n\n// ✅ ADDED: A \"lock\" to prevent multiple syncs at once\nlet isSyncing = false;\n// ✅ ADDED: A timer for debouncing sync pokes\nlet syncTimeout: NodeJS.Timeout | null = null;\n// ✅ ADDED: A custom event name to \"poke\" the sync service\nconst SYNC_TRIGGER_EVENT = \"taskglyph-sync-trigger\";\n\n// ✅ ADDED: A new function to call from your hooks (useTasks, etc.)\nexport function triggerSync() {\n  console.log(\"Poking sync service...\");\n  window.dispatchEvent(new Event(SYNC_TRIGGER_EVENT));\n}\n\n// Check if user is online\nexport function isOnline(): boolean {\n  return typeof window !== \"undefined\" && navigator.onLine;\n}\n\n// Get user tier from IndexedDB\nasync function getUserTier(userId: string): Promise<string> {\n  const userMeta = await db.userMetadata.get(userId);\n  return userMeta?.tier || \"free\";\n}\n\n// Flush sync outbox to server\nexport async function flushSyncOutbox(userId: string): Promise<void> {\n  // ✅ ADDED: Check online status and sync lock\n  if (!isOnline()) {\n    console.log(\"Offline, flush aborted.\");\n    return;\n  }\n  if (isSyncing) {\n    console.log(\"Sync already in progress, skipping flush request.\");\n    return;\n  }\n  isSyncing = true;\n\n  // ✅ ALL TIERS SYNC NOW — including Free (with limits enforced on server)\n  const outbox = await db.syncOutbox.toArray();\n  if (outbox.length === 0) {\n    console.log(\"✅ Sync outbox is empty\");\n    isSyncing = false; // ✅ Release lock\n    return;\n  }\n\n  console.log(`📤 Flushing ${outbox.length} operations to server...`);\n\n  try {\n    const response = await fetch(\"/api/sync\", {\n      method: \"POST\",\n      credentials: \"include\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ operations: outbox }),\n    });\n\n    if (!response.ok) {\n      let errorText = \"Unknown error\";\n      try {\n        const error = await response.json();\n        errorText = JSON.stringify(error, null, 2);\n      } catch {\n        errorText = await response.text();\n      }\n      console.log(`❌ Sync failed: ${errorText}`);\n      return; // Do not delete operations, try again next time\n    }\n\n    const result = await response.json();\n    console.log(\"✅ Sync result:\", result);\n\n    // Remove successfully synced operations\n    const successIds = result.results\n      .filter((r: any) => r.success)\n      .map((r: any) => r.id);\n\n    if (successIds.length > 0) {\n      await db.syncOutbox.bulkDelete(successIds);\n      console.log(\n        `🗑️ Removed ${successIds.length} synced operations from outbox`\n      );\n    }\n  } catch (error) {\n    console.error(\"❌ Network error during sync:\", error);\n  } finally {\n    // ✅ ADDED: Always release the lock\n    isSyncing = false;\n  }\n}\n\n// Start background sync (call this on app load)\nexport function startBackgroundSync(userId: string): () => void {\n  // 1. Sync immediately if online\n  if (isOnline()) {\n    flushSyncOutbox(userId);\n  }\n\n  // 2. Listen for online events (sync immediately)\n  const handleOnline = () => {\n    console.log(\"🌐 Back online — triggering sync\");\n    flushSyncOutbox(userId);\n  };\n  window.addEventListener(\"online\", handleOnline);\n\n  // 3. ✅ ADDED: Listen for pokes (debounced sync)\n  const handleSyncTrigger = () => {\n    if (syncTimeout) {\n      clearTimeout(syncTimeout);\n    }\n    console.log(\"Sync poke received, debouncing...\");\n    syncTimeout = setTimeout(() => {\n      flushSyncOutbox(userId);\n    }, 1500); // 1.5 second debounce\n  };\n  window.addEventListener(SYNC_TRIGGER_EVENT, handleSyncTrigger);\n\n  // 4. Return cleanup function\n  return () => {\n    window.removeEventListener(\"online\", handleOnline);\n    // ✅ ADDED: Cleanup for new listener and timeout\n    window.removeEventListener(SYNC_TRIGGER_EVENT, handleSyncTrigger);\n    if (syncTimeout) {\n      clearTimeout(syncTimeout);\n    }\n  };\n}\n"],"names":[],"mappings":"AAAA,oDAAoD,GACpD,qDAAqD;;;;;;;;;;AACrD;;AAEA,sDAAsD;AACtD,IAAI,YAAY;AAChB,6CAA6C;AAC7C,IAAI,cAAqC;AACzC,0DAA0D;AAC1D,MAAM,qBAAqB;AAGpB,SAAS;IACd,QAAQ,GAAG,CAAC;IACZ,OAAO,aAAa,CAAC,IAAI,MAAM;AACjC;AAGO,SAAS;IACd,OAAO,gBAAkB,eAAe,UAAU,MAAM;AAC1D;AAEA,+BAA+B;AAC/B,eAAe,YAAY,MAAc;IACvC,MAAM,WAAW,MAAM,uIAAE,CAAC,YAAY,CAAC,GAAG,CAAC;IAC3C,OAAO,UAAU,QAAQ;AAC3B;AAGO,eAAe,gBAAgB,MAAc;IAClD,6CAA6C;IAC7C,IAAI,CAAC,YAAY;QACf,QAAQ,GAAG,CAAC;QACZ;IACF;;;IAOA,yEAAyE;IACzE,MAAM;AAiDR;AAGO,SAAS,oBAAoB,MAAc;IAChD,gCAAgC;IAChC,IAAI;;IAIJ,iDAAiD;IACjD,MAAM,eAAe;QACnB,QAAQ,GAAG,CAAC;QACZ,gBAAgB;IAClB;IACA,OAAO,gBAAgB,CAAC,UAAU;IAElC,gDAAgD;IAChD,MAAM,oBAAoB;QACxB,IAAI,aAAa;YACf,aAAa;QACf;QACA,QAAQ,GAAG,CAAC;QACZ,cAAc,WAAW;YACvB,gBAAgB;QAClB,GAAG,OAAO,sBAAsB;IAClC;IACA,OAAO,gBAAgB,CAAC,oBAAoB;IAE5C,6BAA6B;IAC7B,OAAO;QACL,OAAO,mBAAmB,CAAC,UAAU;QACrC,gDAAgD;QAChD,OAAO,mBAAmB,CAAC,oBAAoB;QAC/C,IAAI,aAAa;YACf,aAAa;QACf;IACF;AACF","debugId":null}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///Users/ramanakumar/taskglyph/src/app/layout-client.tsx"],"sourcesContent":["\"use client\";\n\nimport { SessionProvider, useSession } from \"next-auth/react\";\nimport { useEffect } from \"react\";\nimport { startBackgroundSync } from \"@/lib/sync/syncService\";\n\n// We create a new component that *contains* the sync logic\n// because we can only call useSession() inside a <SessionProvider>.\nfunction SyncManager({ children }: { children: React.ReactNode }) {\n  const { data: session } = useSession();\n\n  // ✅ ADDED: Start background sync for authenticated users\n  useEffect(() => {\n    if (session?.user?.id) {\n      console.log(\"Starting global background sync...\");\n      const cleanup = startBackgroundSync(session.user.id);\n      return cleanup; // Clean up event listener on unmount\n    }\n  }, [session?.user?.id]);\n\n  return <>{children}</>;\n}\n\nexport default function LayoutClient({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <SessionProvider>\n      {/* ✅ WRAPPED: We wrap the children in our new SyncManager */}\n      <SyncManager>{children}</SyncManager>\n    </SessionProvider>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAJA;;;;;AAMA,2DAA2D;AAC3D,oEAAoE;AACpE,SAAS,YAAY,EAAE,QAAQ,EAAiC;IAC9D,MAAM,EAAE,MAAM,OAAO,EAAE,GAAG,IAAA,4JAAU;IAEpC,yDAAyD;IACzD,IAAA,kNAAS,EAAC;QACR,IAAI,SAAS,MAAM,IAAI;YACrB,QAAQ,GAAG,CAAC;YACZ,MAAM,UAAU,IAAA,wJAAmB,EAAC,QAAQ,IAAI,CAAC,EAAE;YACnD,OAAO,SAAS,qCAAqC;QACvD;IACF,GAAG;QAAC,SAAS,MAAM;KAAG;IAEtB,qBAAO;kBAAG;;AACZ;AAEe,SAAS,aAAa,EACnC,QAAQ,EAGT;IACC,qBACE,8OAAC,iKAAe;kBAEd,cAAA,8OAAC;sBAAa;;;;;;;;;;;AAGpB","debugId":null}}]
}